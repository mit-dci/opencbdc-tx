// Copyright (c) 2021 MIT Digital Currency Initiative,
//                    Federal Reserve Bank of Boston
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#ifndef OPENCBDC_TX_SRC_SENTINEL_INTERFACE_H_
#define OPENCBDC_TX_SRC_SENTINEL_INTERFACE_H_

#include "uhs/transaction/validation.hpp"
#include "util/common/hash.hpp"
#include "util/network/connection_manager.hpp"

#include <optional>
#include <string>

namespace cbdc::sentinel {
    /// Status of the transaction following sentinel processing.
    enum class tx_status {
        /// Statically valid, and the sentinel has submitted
        /// the transaction to the network for processing.
        pending,
        /// Statically invalid. Must be fixed and resubmitted.
        static_invalid,
        /// Statically valid, but rejected by the shards for trying to spend
        /// inputs either that do not exist or that a previous transaction
        /// already spent.
        state_invalid,
        /// Executed to completion. Included in a block generated by the
        /// atomizer cluster or completed by a distributed transaction batch
        /// coordinated between locking shards.
        confirmed
    };

    /// Sentinel-specific representation of shard network information.
    struct shard_info {
        /// UHS ID range.
        config::shard_range_t m_range;
        /// Network ID of the peer corresponding to this shard generated by a
        /// call to cbdc::network::network::connect.
        cbdc::network::peer_id_t m_peer_id;
    };

    /// Return a human-readable string describing a \ref tx_status.
    /// \param status tx_status to print.
    /// \return human-readable string.
    auto to_string(tx_status status) -> std::string;

    /// Sentinel request message.
    struct execute_request : public transaction::full_tx {};

    /// Sentinel response message.
    struct execute_response {
        /// Transaction execution status.
        cbdc::sentinel::tx_status m_tx_status{};
        /// Transaction validation error if static validation failed.
        std::optional<transaction::validation::tx_error> m_tx_error;

        auto operator==(const execute_response& rhs) const -> bool;
    };

    /// Request type for transaction validation and attestation. A full
    /// transaction to be validated.
    struct validate_request : transaction::full_tx {};
    /// Response type from transaction validation, a sentinel attestation on
    /// the given transaction.
    using validate_response = transaction::sentinel_attestation;

    /// Sentinel RPC request type. Either a transaction execution or validation
    /// request.
    using request = std::variant<execute_request, validate_request>;
    /// Sentinel RPC response type. Either a transaction execution or
    /// validation response.
    using response = std::variant<execute_response, validate_response>;

    /// Interface for a sentinel.
    class interface {
      public:
        virtual ~interface() = default;

        interface() = default;
        interface(const interface&) = delete;
        auto operator=(const interface&) -> interface& = delete;
        interface(interface&&) = delete;
        auto operator=(interface&&) -> interface& = delete;

        /// Validate transaction on the sentinel, and forward it to the
        /// coordinator or shards depending on the implementation. Return the
        /// execution result.
        /// \param tx transaction to execute.
        /// \return the response from the sentinel or std::nullopt if
        ///         processing failed.
        virtual auto execute_transaction(transaction::full_tx tx)
            -> std::optional<execute_response> = 0;

        /// Validate transaction and generate a sentinel attestation if the
        /// transaction is valid.
        /// \param tx transaction to validate and attest to.
        /// \return sentinel attestation for the given transaction, or
        ///         std::nullopt if the transaction is invalid.
        virtual auto validate_transaction(transaction::full_tx tx)
            -> std::optional<validate_response> = 0;
    };
}

#endif
